# HelmGraph Product Requirements Document (PRD)

## Goals and Background Context

### Goals

*   Improve Operational Efficiency: Reduce the time DevOps and SRE teams spend manually analyzing Helm chart dependencies.
*   Enhanced Understanding: Users can successfully answer complex dependency questions about their Helm charts within minutes.
*   Increased Confidence: Users feel more confident in deploying changes because they can clearly visualize the potential impact.
*   Adoption Rate: Increase the number of unique users or teams actively using the service.
*   Processing Time: Process a standard Helm chart and generate Cypher output in under 60 seconds.

### Background Context

Kubernetes configurations, particularly when managed through Helm, often become highly complex. Existing text-based or tabular tools struggle to visualize the intricate relationships and dependencies between resources defined within these charts. This lack of clear visibility complicates debugging, security analysis, and general cluster management. HelmGraph addresses this by converting Helm chart templates into Cypher queries for Neo4j, offering a powerful, queryable, and visual graph-based representation of Kubernetes deployments. This approach aims to simplify the understanding and analysis of networked Kubernetes applications.

### Change Log

| Date       | Version | Description          | Author |
| :--------- | :------ | :------------------- | :----- |
| 2025-08-18 | 1.0     | Initial PRD Draft    | John   |

## Requirements

### Functional

*   FR1: The service shall accept a local Helm chart path as input.
*   FR2: The service shall execute `helm template` to generate a consolidated Kubernetes manifest.
*   FR3: The service shall parse the manifest to create Cypher nodes for `Deployment`, `Service`, `ConfigMap`, `Secret`, and `Ingress` kinds.
*   FR4: Nodes shall be identified by their `kind`, `metadata.name`, and `metadata.namespace`.
*   FR5: The service shall create Cypher relationships for common connections (e.g., `Service` selecting `Deployment`, `Deployment` mounting `Secret`).
*   FR6: The service shall produce a valid `.cypher` file containing all generated `CREATE` and `MERGE` commands.

### Non Functional

*   NFR1: The service shall be a command-line tool.
*   NFR2: The service shall run on Linux, macOS, and Windows (via WSL).
*   NFR3: The service shall process a Helm chart with approximately 50 resources in under 30 seconds.
*   NFR4: The service shall be developed using Go or Python.
*   NFR5: The service shall not require a database for its own operation.
*   NFR6: The service shall be distributed as a binary.
*   NFR7: The service shall require the `helm` CLI to be installed and available in the user's PATH.
*   NFR8: The MVP shall be developed within 4-6 weeks.
*   NFR9: The project shall be developed by a single engineer.
*   NFR10: The tool's functionality is dependent on the output of the `helm template` command.

## Technical Assumptions

### Repository Structure: Polyrepo

### Service Architecture: Monolith

### Testing Requirements: Unit + Integration

### Additional Technical Assumptions and Requests

*   Backend: Go or Python are preferred for their strong CLI development ecosystem and YAML parsing libraries.
*   Database: The output is for Neo4j, but the service itself does not require a database.
*   Hosting/Infrastructure: As a CLI tool, it will be distributed as a binary. No hosting is required for the MVP.
*   Integration Requirements: Requires the `helm` CLI to be installed and available in the user's PATH.
*   Security/Compliance: The tool only reads local files and does not transmit any data, so the initial security footprint is minimal.
*   Users have `helm` v3 installed and correctly configured on their system.
*   Users have a working knowledge of Cypher and access to a Neo4j database instance to run the output script.
*   The Kubernetes manifests generated by `helm template` will be well-formed YAML.
*   The primary value for users is in the generated Cypher script, not in a visual UI (for the MVP).
*   Parsing Complexity: Kubernetes YAML can be incredibly complex and varied. There's a risk that parsing all the different ways resources can be defined and linked will be more difficult than anticipated.
*   Limited Adoption: The target audience is niche. There's a risk that not enough users will find the tool useful to justify further development post-MVP.
*   Open Question: What are the most critical relationships between Kubernetes objects that users want to visualize?
*   Open Question: How should the service handle custom resource definitions (CRDs)? Should they be ignored, or should there be a way to define custom mapping rules?
*   Area Needing Further Research: A survey of existing open-source tools that perform similar Kubernetes visualization or analysis to identify best practices and potential gaps.
*   Area Needing Further Research: Investigation into robust Go or Python libraries for parsing multi-document YAML streams and handling Kubernetes-specific object structures.

## Epic List

*   **Epic 1: Core HelmGraph Functionality:** Establish the foundational service to convert local Helm charts into Cypher queries, generating nodes and relationships for core Kubernetes resource types and outputting a `.cypher` script.
*   **Epic 2: Expanded Resource & Repository Support:** Enhance HelmGraph to support remote Helm repositories and expand the range of Kubernetes resource types it can parse and represent in the graph.

## Epic 1: Core HelmGraph Functionality

**Goal:** This epic aims to establish the foundational service for HelmGraph. It will enable users to input a local Helm chart, process its templates to generate a Kubernetes manifest, and then convert that manifest into a set of Cypher queries. These queries will represent core Kubernetes resources as nodes and their key relationships as edges, ultimately producing a `.cypher` script ready for import into a Neo4j graph database. This delivers the core value proposition of visualizing Helm chart deployments.

### Story 1.1 Helm Chart Input & Manifest Generation

As a DevOps Engineer,
I want to provide a local Helm chart path as input,
so that HelmGraph can generate a consolidated Kubernetes manifest file.

#### Acceptance Criteria

1.  The tool accepts a local file path to a Helm chart directory as an argument.
2.  The tool successfully executes the `helm template` command using the provided chart path.
3.  The tool captures the complete output of `helm template` as a single, consolidated Kubernetes manifest string.
4.  The tool provides clear error messages if the provided chart path is invalid or if `helm template` execution fails.

### Story 1.2 Core Kubernetes Node Parsing

As a DevOps Engineer,
I want HelmGraph to parse the Kubernetes manifest,
so that it identifies and extracts core resource types as graph nodes.

#### Acceptance Criteria

1.  The tool parses the consolidated Kubernetes manifest, correctly handling multi-document YAML streams.
2.  The tool identifies and extracts resources of the following `kind`s: `Deployment`, `Service`, `ConfigMap`, `Secret`, and `Ingress`.
3.  For each identified resource, the tool extracts its `kind`, `metadata.name`, and `metadata.namespace`.
4.  The extracted data for each resource is structured appropriately for conversion into a Neo4j node.

### Story 1.3 Relationship Identification (Service & Deployment)

As a DevOps Engineer,
I want HelmGraph to identify relationships between Services and Deployments,
so that I can visualize how Services route traffic to specific application instances.

#### Acceptance Criteria

1.  The tool analyzes `Service` resources to identify their `selector` labels.
2.  The tool matches `Service` selectors to `Deployment` resources that have matching labels.
3.  For each identified match, the tool establishes a "SELECTS" relationship between the `Service` node and the `Deployment` node.
4.  The relationship includes relevant properties, such as the `selector_labels` used for the connection.

### Story 1.4 Relationship Identification (Deployment & ConfigMap/Secret)

As a DevOps Engineer,
I want HelmGraph to identify relationships between Deployments and ConfigMaps/Secrets,
so that I can understand which configurations and sensitive data are used by my applications.

#### Acceptance Criteria

1.  The tool analyzes `Deployment` resources to identify references to `ConfigMap` and `Secret` resources.
2.  The tool identifies references through common mechanisms like `volumeMounts`, `envFrom`, and `env` variables.
3.  For each identified reference, the tool establishes a "USES_CONFIG" relationship between the `Deployment` node and the `ConfigMap` node, or a "USES_SECRET" relationship between the `Deployment` node and the `Secret` node.
4.  The relationships include relevant properties, such as `mount_path` or `env_var_name`, where applicable.

### Story 1.5 Cypher Script Generation & Output

As a DevOps Engineer,
I want HelmGraph to generate a Cypher script,
so that I can import the Helm chart's graph representation into Neo4j.

#### Acceptance Criteria

1.  The tool generates a valid `.cypher` file containing Cypher `CREATE` or `MERGE` commands.
2.  The `.cypher` file includes commands for all identified nodes (`Deployment`, `Service`, `ConfigMap`, `Secret`, `Ingress`) with their respective properties (`kind`, `name`, `namespace`).
3.  The `.cypher` file includes commands for all identified relationships (e.g., "SELECTS", "USES_CONFIG", "USES_SECRET") with their respective properties.
4.  The generated `.cypher` file is saved to a user-specified or default output location.
5.  The generated Cypher is syntactically correct and can be executed against a Neo4j database.

## Epic 2: Expanded Resource & Repository Support

**Goal:** This epic aims to extend HelmGraph's capabilities beyond local Helm charts and core Kubernetes resource types. It will enable the service to fetch charts from remote repositories and parse a wider array of Kubernetes resource kinds, thereby increasing the breadth of graph representations and providing more comprehensive insights into complex deployments.

### Story 2.1 Remote Helm Repository Integration

As a DevOps Engineer,
I want HelmGraph to fetch Helm charts from remote repositories (URLs or OCI registries),
so that I can analyze charts without needing to download them locally first.

#### Acceptance Criteria

1.  The tool accepts a remote Helm repository URL or OCI registry path as input.
2.  The tool successfully fetches the specified Helm chart from the remote repository.
3.  The tool integrates the fetched chart into the existing manifest generation process (Story 1.1).
4.  The tool provides clear error messages if the remote repository is inaccessible or the chart cannot be fetched.

### Story 2.2 Expanded Kubernetes Resource Type Support

As a DevOps Engineer,
I want HelmGraph to parse additional Kubernetes resource types,
so that I can get a more complete graph representation of my deployments.

#### Acceptance Criteria

1.  The tool expands its parsing capabilities to include `StatefulSet`, `DaemonSet`, and `PersistentVolumeClaim` kinds.
2.  For each newly supported resource kind, the tool correctly extracts its `kind`, `metadata.name`, and `metadata.namespace`.
3.  The tool identifies and establishes relevant relationships for these new resource types (e.g., `StatefulSet` using `PersistentVolumeClaim`).
4.  The generated Cypher script (Story 1.5) includes nodes and relationships for these expanded resource types.
