# Technical Assumptions

### Repository Structure: Monorepo

### Service Architecture: Monolith

### Testing Requirements: Unit + Integration

### Additional Technical Assumptions and Requests

*   Backend: Go is preferred for its strong CLI development ecosystem and YAML parsing libraries and small footprint.
*   Database: The output is for Neo4j, but the service itself does not require a database.
*   Hosting/Infrastructure: As a CLI tool, it will be distributed as a binary. No hosting is required for the MVP.
*   Security/Compliance: The tool only reads local files and does not transmit any data, so the initial security
    footprint is minimal.
*   Users have a working knowledge of Cypher and access to a Neo4j database instance to run the output script.
*   The Kubernetes manifests generated by `helm template` will be well-formed YAML.
*   The primary value for users is in the generated Cypher script, not in a visual UI (for the MVP).
*   Parsing Complexity: Kubernetes YAML can be incredibly complex and varied. There's a risk that parsing all the
    different ways resources can be defined and linked will be more difficult than anticipated.
*   Limited Adoption: The target audience is niche. There's a risk that not enough users will find the tool useful
    to justify further development post-MVP.
*   Open Question: What are the most critical relationships between Kubernetes objects that users want to visualize?
*   Open Question: How should the service handle custom resource definitions (CRDs)? Should they be ignored, or
    should there be a way to define custom mapping rules?
*   Area Needing Further Research: A survey of existing open-source tools that perform similar Kubernetes
    visualization or analysis to identify best practices and potential gaps.
*   Area Needing Further Research: Investigation into robust Go or Python libraries for parsing multi-document YAML
    streams and handling Kubernetes-specific object structures.
